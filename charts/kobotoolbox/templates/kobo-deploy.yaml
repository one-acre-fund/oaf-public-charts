apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}-kobo
  namespace: {{ .Release.Namespace }}
spec:
  replicas: {{ .Values.general.replicas }}
  selector:
    matchLabels:
      org.kobotoolbox.instance: {{ .Release.Name }}-kobo
  template:
    metadata:
      annotations:
        # Add a checksum to force the re-creation of the pods on every config update
        # TODO: better checksum?
        checksum/config: {{ .Values | toString | sha256sum }}
        checksum/nginx_conf: {{ include "nginx_conf" . | sha256sum }}
        co.elastic.logs/enabled: "true"
        prometheus.io/scrape: "true"
        prometheus.io/port: "9117"
        prometheus.io/path: "/metrics"
      labels:
        org.kobotoolbox.instance: {{ .Release.Name }}-kobo
    spec:
      # Define internal host names since we're doing host-based routing
      hostAliases:
        - ip: "127.0.0.1"
          hostnames:
            - "{{ .Values.kpi.subdomain }}.kobo.local"
            - "{{ .Values.kobocat.subdomain }}.kobo.local"
            {{- if .Values.general.forceInternal }}
            - "{{ .Values.kpi.subdomain }}.{{ .Values.general.externalDomain }}"
            - "{{ .Values.kobocat.subdomain }}.{{ .Values.general.externalDomain }}"
            {{- end }}

      initContainers:
        # Wait for Mongo and Postgres
        - name: wait-db
          image: jwilder/dockerize
          # We don't care about having latest...
          imagePullPolicy: IfNotPresent
          command:
            - sh
            - -c
            - dockerize -timeout=120s -wait tcp://${KOBO_MONGO_HOST}:${KOBO_MONGO_PORT} -wait tcp://${POSTGRES_HOST}:${POSTGRES_PORT}
          env:
            {{- include "env_mongo" . | nindent 12 }}
            {{- include "env_postgres" . | nindent 12 }}
      # All containers need to be in the same pod since they share volumes!
      # This also means they probably can't be scaled up... (?)
      containers:
        # Nginx does the host-based routing for all containers
        - name: nginx
          image: nginx:1.21
          volumeMounts:
            # Config
            - name: nginx-confd
              mountPath: /etc/nginx/conf.d
            # empty init dir
            - name: nginx-init
              mountPath: /docker-entrypoint.d
            # Web files (generated by other containers)
            - name: cache-volume
              subPath: static
              mountPath: /srv/www
            - name: media
              subPath: kobocat_media_uploads
              mountPath: /media
            # expose kpi media
            - name: media
              subPath: kpi_media
              mountPath: /srv/kpi_media
          {{- if .Values.probes.enabled }}
          readinessProbe:
            httpGet:
              path: /api/v2/
              port: 80
              httpHeaders:
                - name: Host
                  value: {{ .Values.kpi.subdomain }}.{{ include "internal_domain" . }}
            initialDelaySeconds: 120
            periodSeconds: 60
            failureThreshold: 15
          livenessProbe:
            httpGet:
              path: /api/v2/
              port: 80
              httpHeaders:
                - name: Host
                  value: {{ .Values.kpi.subdomain }}.{{ include "internal_domain" . }}
            initialDelaySeconds: 160
            failureThreshold: 15
            periodSeconds: 30
          {{- end }}
        # Kobocat is the forms API server that Enketo / Collect will connect to
        - name: kobocat
          image: "{{ .Values.kobocat.image.name }}:{{ .Values.kobocat.image.tag }}"
          terminationMessagePolicy: FallbackToLogsOnError
          # command:
          #   - "/bin/bash"
          #   - -c
          #   - python3 -m venv /opt/venv && pip uninstall -y django-oauth-toolkit && pip install django-oauth-toolkit==1.3.2 && exec ${KOBOCAT_SRC_DIR}/docker/init.bash
          ports:
            - containerPort: 8001
            - name: metrics
              containerPort: 1717
              protocol: TCP
          env:
            {{- include "env_general" . | nindent 12 }}
            {{- include "env_mongo" . | nindent 12 }}
            {{- include "env_postgres" . | nindent 12 }}
            {{- include "env_redis" . | nindent 12 }}
            {{- include "env_externals" . | nindent 12 }}
            {{- include "env_kobocat" . | nindent 12 }}
            {{- include "env_uwsgi" "KC" | nindent 12 }}
            {{- include "env_smtp" . | nindent 12 }}
            - name: ENKETO_PROTOCOL
              value: http
            - name: KPI_PORT
              value: '8003'
            {{- range $key, $value := .Values.kobocat.extraEnv }}
            - name: {{ $key | quote }}
              value: |-
                {{- tpl $value $ | nindent 16 }}
            {{- end }}
          envFrom:
          - secretRef:
              name: {{ .Release.Name }}-kobocat-secrets
          volumeMounts:
            # Replace redundant init scripts with empty files
            - name: config
              mountPath: /srv/init/wait_for_mongo.bash
              subPath: empty_script
              readOnly: true
            - name: config
              mountPath: /srv/init/wait_for_postgres.bash
              subPath: empty_script
              readOnly: true
            # Config
            - name: config
              mountPath: /srv/src/kobocat/docker/kobocat.ini
              subPath: kc_uwsgi.ini
              readOnly: true
            # Store uploaded media in PVC
            - name: media
              subPath: kobocat_media_uploads
              mountPath: /srv/src/kobocat/media
            - name: cache-volume
              subPath: static/kobocat
              mountPath: /srv/static
          {{- if .Values.probes.enabled }}
          readinessProbe:
            tcpSocket:
              port: 8001
            initialDelaySeconds: 10
            periodSeconds: 20
          livenessProbe:
            tcpSocket:
              port: 8001
            initialDelaySeconds: 30
            periodSeconds: 20
        {{- end }}
        # KPI is the main User Interface and admin API
        - name: kpi
          image: "{{ .Values.kpi.image.name }}:{{ .Values.kpi.image.tag }}"
          terminationMessagePolicy: FallbackToLogsOnError
          # Override entrypoint to redirect logs to stdout
          # command:
          #   - sh
          #   - -c
          #   - |
          #     # Init log files so we can pipe them
          #     touch /srv/logs/celery_beat.log && touch /srv/logs/celery.log && touch /srv/logs/celery_sync_kobocat_xforms.log

          #     # Run with dockerize
          #     dockerize -stdout /srv/logs/celery_beat.log -stdout /srv/logs/celery.log -stdout /srv/logs/celery_sync_kobocat_xforms.log /srv/src/kpi/docker/init.bash
          # - cat
          # tty: true
          env:
            {{- include "env_general" . | nindent 12 }}
            {{- include "env_mongo" . | nindent 12 }}
            {{- include "env_postgres" . | nindent 12 }}
            {{- include "env_redis" . | nindent 12 }}
            {{- include "env_externals" . | nindent 12 }}
            {{- include "env_kpi" . | nindent 12 }}
            {{- include "env_uwsgi" "KPI" | nindent 12 }}
            {{- include "env_smtp" . | nindent 12 }}
            - name: SYNC_KOBOCAT_XFORMS
              value: 'True'
            - name: C_FORCE_ROOT
              value: 'True'
            {{- range $key, $value := .Values.kpi.extraEnv }}
            - name: {{ $key | quote }}
              value: |-
                {{- tpl $value $ | nindent 16 }}
            {{- end }}
          envFrom:
          - secretRef:
              name: {{ .Release.Name }}-kpi-secrets
          ports:
            - containerPort: 8003
            - name: metrics
              containerPort: 1818
              protocol: TCP
          volumeMounts:
            # Override init scripts with empty ones
            - name: config
              subPath: empty_script
              mountPath: /srv/init/wait_for_mongo.bash
              readOnly: true
            - name: config
              subPath: empty_script
              mountPath: /srv/init/wait_for_postgres.bash
              readOnly: true
            - name: config
              subPath: empty_script
              mountPath: /etc/profile.d/runtime_variables_kpi.source.bash.sh
              readOnly: true
            # Web server settings
            - name: config
              subPath: kpi_uwsgi.ini
              mountPath: /srv/src/kpi/uwsgi.ini
              readOnly: true
            # www
            - name: cache-volume
              subPath: static/kpi
              mountPath: /srv/static
            # media
            - name: media
              subPath: kpi_media
              mountPath: /srv/src/kpi/media
            - name: media
              subPath: kobocat_media_uploads
              mountPath: /srv/src/kobocat/media
          readinessProbe:
            tcpSocket:
              port: 8003
            initialDelaySeconds: 300
            periodSeconds: 20
          livenessProbe:
            tcpSocket:
              port: 8003
            initialDelaySeconds: 330
            periodSeconds: 20
      volumes:
        - name: nginx-confd
          configMap:
            name: {{ .Release.Name }}-nginx-confd
        - name: config
          configMap:
            name: {{ .Release.Name }}-kobo
            # Grant exec permissions
            defaultMode: 0755
        - name: kobo-assets
          configMap:
            name: {{ .Release.Name }}-assets
        # This volume will host uploaded media. If the pod is scaled to more than 1 replica, it needs to be ReadWriteMany
        - name: media
          persistentVolumeClaim:
            claimName: {{ .Release.Name }}-kobo-media
        # Using an emptyDir to cache compiled statics... it will survive container crashes, but not pod restarts
        - name: cache-volume
          emptyDir: {}
        - name: nginx-init
          emptyDir: {}
