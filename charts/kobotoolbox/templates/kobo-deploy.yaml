apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}-kobo
  namespace: {{ .Release.Namespace }}
spec:
  replicas: {{ .Values.general.replicas }}
  selector:
    matchLabels:
      org.kobotoolbox.instance: {{ .Release.Name }}-kobo
  template:
    metadata:
      annotations:
        # Add a checksum to force the re-creation of the pods on every config update
        # TODO: better checksum?
        checksum/config: {{ .Values | toString | sha256sum }}
        checksum/nginx_conf: {{ include "nginx_conf" . | sha256sum }}
        co.elastic.logs/enabled: "true"
        prometheus.io/scrape: "true"
        prometheus.io/port: "9117"
        prometheus.io/path: "/metrics"
      labels:
        org.kobotoolbox.instance: {{ .Release.Name }}-kobo
    spec:
      priorityClassName: {{ .Values.priorityClass }}
      # Define internal host names since we're doing host-based routing
      hostAliases:
        - ip: "127.0.0.1"
          hostnames:
            - "{{ .Values.kpi.subdomain }}.kobo.local"
            - "{{ .Values.kobocat.subdomain }}.kobo.local"
            {{- if .Values.general.forceInternal }}
            - "{{ .Values.kpi.subdomain }}.{{ .Values.general.externalDomain }}"
            - "{{ .Values.kobocat.subdomain }}.{{ .Values.general.externalDomain }}"
            {{- end }}

      initContainers:
        # Wait for Mongo and Postgres
        - name: wait-db
          image: jwilder/dockerize
          # We don't care about having latest...
          imagePullPolicy: IfNotPresent
          command:
            - sh
            - -c
            - dockerize -timeout=120s -wait tcp://${KOBO_MONGO_HOST}:${KOBO_MONGO_PORT} -wait tcp://${POSTGRES_HOST}:${POSTGRES_PORT}
          env:
            {{- include "env_mongo" . | nindent 12 }}
            {{- include "env_postgres" . | nindent 12 }}
        {{- if .Values.shared.initContainers }}
        {{ tpl (toYaml .Values.shared.initContainers) . | nindent 8 }}
        {{- end }}
      # All containers need to be in the same pod since they share volumes!
      # This also means they probably can't be scaled up... (?)
      containers:
        # Nginx does the host-based routing for all containers
        - name: nginx
          image: "{{ .Values.nginx.image.name }}:{{ .Values.nginx.image.tag }}"
          volumeMounts:
            # Config
            - name: nginx-confd
              mountPath: /etc/nginx/conf.d
            # empty init dir
            - name: nginx-init
              mountPath: /docker-entrypoint.d
            # Web files (generated by other containers)
            - name: cache-volume
              subPath: static
              mountPath: /srv/www
            - name: media
              subPath: kobocat_media_uploads
              mountPath: /media
            # expose kpi media
            - name: media
              subPath: kpi_media
              mountPath: /srv/kpi_media
          {{- if .Values.probes.enabled }}
          startupProbe:
            httpGet:
            tcpSocket:
              port: 80
            periodSeconds: 10
            failureThreshold: 30
          readinessProbe:
            tcpSocket:
              port: 80
            periodSeconds: 5
            failureThreshold: 5
          livenessProbe:
            tcpSocket:
              port: 80
            failureThreshold: 5
            periodSeconds: 5
          {{- end }}
        # Kobocat is the forms API server that Enketo / Collect will connect to
        - name: kobocat
          image: "{{ .Values.kobocat.image.name }}:{{ .Values.kobocat.image.tag }}"
          terminationMessagePolicy: FallbackToLogsOnError
          {{- if .Values.kobocat.command }}
          command:
            {{- .Values.kobocat.command | toYaml | nindent 12 }}
          {{- end }}
          ports:
            - containerPort: 8001
            - name: metrics
              containerPort: 1717
              protocol: TCP
          env:
            {{- include "env_general" . | nindent 12 }}
            {{- include "env_mongo" . | nindent 12 }}
            {{- include "env_postgres" . | nindent 12 }}
            {{- include "env_externals" . | nindent 12 }}
            {{- include "env_kobocat" . | nindent 12 }}
            {{- include "env_smtp" . | nindent 12 }}
            - name: KPI_PORT
              value: '8003'
            {{- range $key, $value := .Values.kobocat.extraEnv }}
            - name: {{ $key | quote }}
              value: |-
                {{- tpl $value $ | nindent 16 }}
            {{- end }}
            {{- range $key, $value := .Values.shared.extraEnv }}
            - name: {{ $key | quote }}
              value: |-
                {{- tpl $value $ | nindent 16 }}
            {{- end }}
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: {{ .Release.Name }}-secrets
                  key: KC_DATABASE_URL
          envFrom:
          - secretRef:
              name: {{ .Release.Name }}-kobocat-secrets
          - secretRef:
              name: {{ .Release.Name }}-secrets
          volumeMounts:
            # Replace redundant init scripts with empty files
            - name: config
              mountPath: /srv/init/wait_for_mongo.bash
              subPath: empty_script
              readOnly: true
            - name: config
              mountPath: /srv/init/wait_for_postgres.bash
              subPath: empty_script
              readOnly: true
            # Config
            - name: config
              mountPath: /srv/src/kobocat/docker/uwsgi.ini
              subPath: kc_uwsgi.ini
              readOnly: true
            # Store uploaded media in PVC
            - name: media
              subPath: kobocat_media_uploads
              mountPath: /srv/src/kobocat/media
            - name: cache-volume
              subPath: static/kobocat
              mountPath: /srv/static
          {{- if .Values.probes.enabled }}
          startupProbe:
            tcpSocket:
              port: 8001
            failureThreshold: 30
            periodSeconds: 10
          readinessProbe:
            tcpSocket:
              port: 8001
            failureThreshold: 5
            periodSeconds: 5
          livenessProbe:
            tcpSocket:
              port: 8001
            failureThreshold: 5
            periodSeconds: 5
          {{- end }}
        # KPI is the main User Interface and admin API
        - name: kpi
          image: "{{ .Values.kpi.image.name }}:{{ .Values.kpi.image.tag }}"
          terminationMessagePolicy: FallbackToLogsOnError
          {{- if .Values.kpi.command }}
          command:
            {{- .Values.kpi.command | toYaml | nindent 12 }}
          {{- end }}
          env:
            {{- include "env_general" . | nindent 12 }}
            {{- include "env_mongo" . | nindent 12 }}
            {{- include "env_postgres" . | nindent 12 }}
            {{- include "env_externals" . | nindent 12 }}
            {{- include "env_kpi" . | nindent 12 }}
            {{- include "env_smtp" . | nindent 12 }}
            {{- range $key, $value := .Values.kpi.extraEnv }}
            - name: {{ $key | quote }}
              value: |-
                {{- tpl $value $ | nindent 16 }}
            {{- end }}
            {{- range $key, $value := .Values.shared.extraEnv }}
            - name: {{ $key | quote }}
              value: |-
                {{- tpl $value $ | nindent 16 }}
            {{- end }}
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: {{ .Release.Name }}-secrets
                  key: KPI_DATABASE_URL
          envFrom:
          - secretRef:
              name: {{ .Release.Name }}-kpi-secrets
          - secretRef:
              name: {{ .Release.Name }}-secrets
          ports:
            - containerPort: 8003
            - name: metrics
              containerPort: 1818
              protocol: TCP
          volumeMounts:
            # Override init scripts with empty ones
            - name: config
              subPath: empty_script
              mountPath: /srv/init/wait_for_mongo.bash
              readOnly: true
            - name: config
              subPath: empty_script
              mountPath: /srv/init/wait_for_postgres.bash
              readOnly: true
            - name: config
              subPath: empty_script
              mountPath: /etc/profile.d/runtime_variables_kpi.source.bash.sh
              readOnly: true
            # Web server settings
            - name: config
              subPath: kpi_uwsgi.ini
              mountPath: /srv/src/kpi/docker/uwsgi.ini
              readOnly: true
            # www
            - name: cache-volume
              subPath: static/kpi
              mountPath: /srv/static
            # media
            - name: media
              subPath: kpi_media
              mountPath: /srv/src/kpi/media
            - name: media
              subPath: kobocat_media_uploads
              mountPath: /srv/src/kobocat/media
          {{- if .Values.probes.enabled }}
          startupProbe:
            tcpSocket:
              port: 8003
            failureThreshold: 40
            periodSeconds: 10
          readinessProbe:
            tcpSocket:
              port: 8003
            failureThreshold: 5
            periodSeconds: 5
          livenessProbe:
            tcpSocket:
              port: 8003
            failureThreshold: 5
            periodSeconds: 5
          {{- end }}
        {{- if .Values.shared.sidecarContainers }}
        {{- tpl (toYaml .Values.shared.sidecarContainers) $ | nindent 8 }}
        {{- end }}
      volumes:
        - name: nginx-confd
          configMap:
            name: {{ .Release.Name }}-nginx-confd
        - name: config
          configMap:
            name: {{ .Release.Name }}-kobo
            # Grant exec permissions
            defaultMode: 0755
        - name: kobo-assets
          configMap:
            name: {{ .Release.Name }}-assets
        # This volume will host uploaded media. If the pod is scaled to more than 1 replica, it needs to be ReadWriteMany
        - name: media

        {{- if .Values.general.mediaStorage.enabled }}
          persistentVolumeClaim:
            claimName: {{ .Release.Name }}-kobo-media
        {{- else }}
          # using emptyDir since some hardcoded checks are still done on this media directory even if using online storage
          emptyDir: {}
        {{- end }}
        # Using an emptyDir to cache compiled statics... it will survive container crashes, but not pod restarts
        - name: cache-volume
          emptyDir: {}
        - name: nginx-init
          emptyDir: {}
